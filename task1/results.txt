==================== РЕЗУЛЬТАТИ ====================
--- Тестування набору: Малий (N=100) ---
[Insertion Sort (O(n^2))]: 0.000298 сек.
[Merge Sort (O(n log n))]: 0.000252 сек.
[Timsort (sorted) (O(n log n))]: 0.000009 сек.
_________________________________________________________
--- Тестування набору: Середній (N=1000) ---
[Insertion Sort (O(n^2))]: 0.029178 сек.
[Merge Sort (O(n log n))]: 0.001980 сек.
[Timsort (sorted) (O(n log n))]: 0.000148 сек.
_________________________________________________________
--- Тестування набору: Великий (N=10000) ---
[Insertion Sort (O(n^2))]: Пропущено через надто велику складність (N=10000)
[Merge Sort (O(n log n))]: 0.045718 сек.
[Timsort (sorted) (O(n log n))]: 0.002572 сек.
--- Тестування набору: Великий (N=5000) ---
[Insertion Sort (O(n^2))]: Пропущено через надто велику складність (N=5000)
[Merge Sort (O(n log n))]: 0.015289 сек.
[Timsort (sorted) (O(n log n))]: 0.000644 сек.
--- Тестування набору: Великий (N=1500) ---
[Insertion Sort (O(n^2))]: Пропущено через надто велику складність (N=1500)
[Merge Sort (O(n log n))]: 0.003170 сек.
[Timsort (sorted) (O(n log n))]: 0.000164 сек.
_________________________________________________________

==================== ВИСНОВКИ ====================
Проведене емпіричне тестування трьох алгоритмів сортування 
— сортування вставками (O(n^2)), сортування злиттям (O(n log n)) та Timsort (O(n log n)) 
— на наборах даних різного розміру: 100, 1000 і 10000 (5000 і 1500 - щоб відслідкувати, чи менші дані дадуть змогу прогнати insertion_sort.)

1. При сортуванні вставками (Insertion Sort) - ми змогли порівняти лише 100 і 1000.
При збільшенні розміру масиву в 10 разів (від 100 до 1000), час виконання зріс майже в 100 разів (0.000298 сек. -> 0.029178 сек.).
Це емпіричне підтвердження квадратичної складності O(n^2), яка робить цей алгоритм непридатним для середніх та великих масивів. 
Тому тестування на N=1500 не пройшло. 

2. При сортуванні зляттям (Merge Sort): 
При збільшенні розміру масиву в 10 разів (від 1000 до 10000), час виконання зріс лише приблизно у 23 рази (0.001980 сек. -> 0.045718).
Це підтверджує лінійно-логарифмічну складність O(n log n).

3. Порівняння Timsort з  Merge Sort, оскільки обидва мають складність O(n log n):
                           |    100   |   1000   |  10000  
Timsort                    | 0.000009 | 0.000148 | 0.002572
Merge Sort                 | 0.000252 | 0.001980 | 0.045718
Timsort швидший у N разів: |    28    |    13    |    18

Хоча Merge Sort має теоретичну складність O(n log n), Timsort є емпірично ефективнішим і практично швидшим алгоритмом.
Його гібридна, адаптивна структура та високооптимізована реалізація дозволяють йому значно перевершувати чисті алгоритми сортування на реальних даних. 
Це і є головною причиною, чому в більшості випадків програмісти довіряють стандартним бібліотечним функціям.
======================================================================================================================================================